(in-package #:cl-configurator)

;;;;this file contains everything to do with manipulating the configuration tree which has
;;;;been imported and converted to objects as defined in classes.lisp

(defparameter *root-node* ())
(defun modify-value-in-tree (root-node leaf-name value)
  "Modifies the value of leaf in root-node and returns the modified tree structure"
  (unless (keywordp leaf-name)
    (not-keyword-error leaf-name))
  (labels ((rec (node)
	     ;(print node)
	     (cond ((null node)
		    nil)
		   ((listp node)
		    (rec (first node))
		    (rec (rest node)))
		   ((branch-p node)
		    (rec (n-children node)))
		   ((leaf-p node)
		    (when (equal leaf-name (n-name node))
		      (setf (n-value node) value)
		      t))
		   (t nil))))
    (rec (n-children root-node))
    root-node))
(defun append-to-list (list item)
  "appends anything to a list, unlike append which only appends other lists"
  (if (listp item)
      (append list item)
      (append list (list item))))

(defun add-leaf-to-tree (root-node branch-name leaf-name leaf-value)
  "Creates a new leaf and adds it to the children named by branch-name. This will only work
when root-node is made of objects not lists, as lists do not keep track of their parents"
  (unless (keywordp leaf-name)
    (not-keyword-error leaf-name))
  (labels ((rec (node)
	     (cond ((null node)
		    nil)
		   ((listp node)
		    (rec (first node))
		    (rec (rest node)))
		   ((branch-p node)
		    (when (equal (n-name node) branch-name)
		      (let* ((children (n-children node))
			     (parents (n-parents node))
			     (leaf (make-leaf leaf-name parents leaf-value)))
			(setf (n-children node) 
			      (append-to-list children leaf))))
		    (rec (n-children node)))
		   ((leaf-p node)
		    nil)
		   (t nil))))
    (rec (n-children root-node))
    root-node))

(defun add-branch-to-tree (root-node parent branch-name)
  "Creates a new branch by name branch-name and adds it to the parent branch"
  (unless (keywordp branch-name)
    (not-keyword-error branch-name))
  (labels ((rec (node)
	     (cond ((null node)
		    nil)
		   ((listp node)
		    (rec (first node))
		    (rec (rest node)))
		   ((branch-p node)
		    (when (equal (n-name node) parent)
		      (let* ((children (n-children node))
			     (parents (n-parents node))
			     (branch (make-branch branch-name parents nil)))
			(setf (n-children node) 
			      (append-to-list children branch))))
		    (rec (n-children node)))
		   ((leaf-p node)
		    nil)
		   (t nil))))
    (rec (n-children root-node))
    root-node))

(defun remove-branch-or-leaf-from-tree (root-node b-or-l-name)
  "removes branch-or-leaf named by b-or-l-name from root-node"
  (unless (keywordp b-or-l-name)
    (not-keyword-error b-or-l-name))
  (labels ((rec (node)
	     (cond ((null node)
		    nil)
		   ((listp node)
		    (rec (first node))
		    (rec (rest node)))
		   ((branch-p node)
		    (when (contains-child node b-or-l-name)
			(delete-child node b-or-l-name))
		    (rec (n-children node)))
		   ((leaf-p node)
		    nil)
		   (t nil))))
    (rec (n-children root-node))
    root-node))
(defun remove-branch-from-tree (root-node branch-name)
  (remove-branch-or-leaf-from-tree root-node branch-name))
(defun remove-leaf-from-tree (root-node leaf-name)
  (remove-branch-or-leaf-from-tree root-node leaf-name))

(defun object-tree-to-cons (root-node)
  "Creates a nested sexp from the object versions"
  (labels ((rec (node)
	     (cond ((null node)
		    nil)
		   ((listp node)
		    (cons (rec (first node))
			  (rec (rest node))))
		   ((branch-p node)
		    (append (list (n-name node))
			    (rec (n-children node))))
		   ((leaf-p node)
		    (cons (n-name node)
			  (cons (n-value node) nil))))))
    (append (list (n-name root-node))
	    (rec (n-children root-node)))))
